/*
 * Joe Sheppard
 * CSC 380
 * 1/16/2015
 * 
 * The Node class is an object that will stored on the Queue. It contains the state of the Node, its parent
 * and children (used for finding solution) and the depth of the Node (used for duplicate checking(
 */
import java.util.LinkedList;
public class Node implements Comparable<Node> {
	
	
	private Node parent;
	private LinkedList<Node> children;
	private int depth;
	private State state;

	
	Node(){
	}
	
	
	public Node(State state, int depth, Node parent, LinkedList<Node> children)
	{
		this.state=state;
		this.depth=depth;
		this.parent=parent;
		this.children=children;
	}
	
	
	public State getState()
	{
		return state;
	}
	
	public int getDepth()
	{
		return depth;
	}
	
	public Node getParent()
	{
		return parent;
	}
	
	public LinkedList<Node> getChildren()
	{
		return children;
	}
	
	
	//this successor function calls the separate successor function of the state of this Node.
	//then, it returns a list of NODES containing the states generated by the state's successor,
	//while increasing the depth by 1, and setting the parent to this.
	public LinkedList<Node> successor()
	{
		LinkedList<State> tmp = state.successor();
		LinkedList<Node> toReturn = new LinkedList<Node>();
		for(State s:tmp)
		{
			toReturn.add(new Node(s,(depth+1),this,null));
		}
		this.children=toReturn;
		return toReturn;
	}
	
	//overrides the default compareTo method to allow for sorting by the hueristics
	public int compareTo(Node other)
	{
		int t = state.h();
		int o = other.getState().h();
		if(t>o)
			return 1;
		
		if(t<o)
			return -1;
		return 0;
	}
	

	
	
	//traces the solution node back up to the root to generate the set of instructions to go from
	//the root to the goal node. Also supplies the length of solution to the client.
	public String trace()
	{
		String toReturn="";
		Node n = this;
		int length =0;
		while(n.getParent()!=null)
		{
			
			Node parent = n.getParent();
			int currentBlank = n.getState().findBlank();
			int parentBlank = parent.getState().findBlank();
			n=parent;
			if(currentBlank==(parentBlank+3))
			{
				toReturn=" DOWN "+toReturn;
				length++;
				continue;
			}
			if(currentBlank==(parentBlank-3))
			{
				toReturn=" UP "+toReturn;
				length++;
				continue;
			}
			if(currentBlank==(parentBlank+1))
			{
				toReturn=" RIGHT "+toReturn;
				length++;
				continue;
			}
			if(currentBlank==(parentBlank-1))
			{
				toReturn=" LEFT "+toReturn;
				length++;
				continue;
			}
			
			toReturn="ERROR!: "+currentBlank+parentBlank+toReturn;
		}
		
		return toReturn+" --------- Number of Moves: "+length;
	}
	
	

}
